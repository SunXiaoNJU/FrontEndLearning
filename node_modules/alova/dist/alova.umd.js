/**
  * alova 2.2.0 (https://alova.js.org)
  * Document https://alova.js.org
  * Copyright 2023 JOU-amjs. All Rights Reserved
  * Licensed under MIT (https://httpshub.com/alovajs/alova/blob/main/LICENSE)
  */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.alova = {}));
})(this, (function (exports) { 'use strict';

  // 以下为减少编译代码量而添加的统一处理函数或变量
  const PromiseCls = Promise, promiseResolve = (value) => PromiseCls.resolve(value), promiseReject = (value) => PromiseCls.reject(value), ObjectCls = Object, undefinedValue = undefined, nullValue = null, trueValue = true, falseValue = false, promiseThen = (promise, onFulfilled, onrejected) => promise.then(onFulfilled, onrejected), promiseCatch = (promise, onrejected) => promise.catch(onrejected), getTime = (date) => (date ? date.getTime() : Date.now()), getContext = (methodInstance) => methodInstance.context, getConfig = (methodInstance) => methodInstance.config, getContextOptions = (alovaInstance) => alovaInstance.options, getOptions = (methodInstance) => getContextOptions(getContext(methodInstance)), getStatesHook = (alovaInstance) => getContextOptions(alovaInstance).statesHook, JSONStringify = (value) => JSON.stringify(value), JSONParse = (value) => JSON.parse(value), setTimeoutFn = (fn, delay = 0) => setTimeout(fn, delay), clearTimeoutTimer = (timer) => clearTimeout(timer), objectKeys = (obj) => ObjectCls.keys(obj), forEach = (ary, fn) => ary.forEach(fn), pushItem = (ary, ...item) => ary.push(...item), len = (data) => data.length, isArray = (arg) => Array.isArray(arg), deleteAttr = (arg, attr) => delete arg[attr], 
  /** 三种缓存模式 */
  // 只在内存中缓存，默认是此选项
  MEMORY = 'memory', 
  // 缓存会持久化，但当内存中没有缓存时，持久化缓存只会作为响应数据的占位符，且还会发送请求更新缓存
  STORAGE_PLACEHOLDER = 'placeholder', 
  // 缓存会持久化，且每次刷新会读取持久化缓存到内存中，这意味着内存一直会有缓存
  STORAGE_RESTORE = 'restore', 
  // 是否为服务端渲染
  isSSR = typeof window === 'undefined';

  /**
   * 空函数，做兼容处理
   */
  const noop = () => { };
  /**
   * 返回参数自身的函数，做兼容处理用
   * 由于部分系统将self作为了保留字，故使用_self来区分
   * @param arg 任意参数
   * @returns 返回参数本身
   */
  const _self = (arg) => arg;
  /**
   * 判断参数是否为函数
   * @param fn 任意参数
   * @returns 该参数是否为函数
   */
  const isFn = (arg) => typeof arg === 'function';
  /**
   * 判断参数是否为数字
   * @param arg 任意参数
   * @returns 该参数是否为数字
   */
  const isNumber = (arg) => typeof arg === 'number' && !isNaN(arg);
  /**
   * 判断参数是否为字符串
   * @param arg 任意参数
   * @returns 该参数是否为字符串
   */
  const isString = (arg) => typeof arg === 'string';
  /**
   * 全局的toString
   * @param arg 任意参数
   * @returns 字符串化的参数
   */
  const globalToString = (arg) => ObjectCls.prototype.toString.call(arg);
  /**
   * 判断是否为普通对象
   * @param arg 任意参数
   * @returns 判断结果
   */
  const isPlainObject = (arg) => globalToString(arg) === '[object Object]';
  /**
   * 判断是否为某个类的实例
   * @param arg 任意参数
   * @returns 判断结果
   */
  const instanceOf = (arg, cls) => arg instanceof cls;
  /**
   * 是否为特殊数据
   * @param data 提交数据
   * @returns 判断结果
   */
  const isSpecialRequestBody = (data) => {
      const dataTypeString = globalToString(data);
      return (/^\[object (Blob|FormData|ReadableStream|URLSearchParams)\]$/i.test(dataTypeString) || instanceOf(data, ArrayBuffer));
  };
  /**
   * 获取请求方式的key值
   * @returns {string} 此请求方式的key值
   */
  const key = (methodInstance) => {
      const { type, url, data } = methodInstance;
      const { params, headers } = getConfig(methodInstance);
      return JSONStringify([type, url, params, data, headers]);
  };
  /**
   * 创建防抖函数，当delay为0时立即触发函数
   * 场景：在调用useWatcher并设置了immediate为true时，首次调用需立即执行，否则会造成延迟调用
   * @param {GeneralFn} fn 回调函数
   * @param {number|(...args: any[]) => number} delay 延迟描述，设置为函数时可实现动态的延迟
   * @returns 延迟后的回调函数
   */
  const debounce = (fn, delay) => {
      let timer = nullValue;
      return function (...args) {
          const bindFn = fn.bind(this, ...args);
          timer && clearTimeoutTimer(timer);
          const delayMill = isNumber(delay) ? delay : delay(...args);
          if (delayMill > 0) {
              timer = setTimeoutFn(bindFn, delayMill);
          }
          else {
              bindFn();
          }
      };
  };
  /**
   * 获取缓存的配置参数，固定返回{ e: number, m: number, s: boolean, t: string }格式的对象
   * e为expire缩写，表示缓存失效时间点（时间戳），单位为毫秒
   * m为mode缩写，存储模式
   * s为storage缩写，是否存储到本地
   * t为tag缩写，持久化存储标签
   * @param localCache 本地缓存参数
   * @returns 统一的缓存参数对象
   */
  const getLocalCacheConfigParam = (methodInstance) => {
      const _localCache = getConfig(methodInstance).localCache;
      const getCacheExpireTs = (_localCache) => isNumber(_localCache) ? getTime() + _localCache : getTime(_localCache);
      let cacheMode = MEMORY;
      let expire = 0;
      let storage = falseValue;
      let tag = undefinedValue;
      if (!isFn(_localCache)) {
          if (isNumber(_localCache) || instanceOf(_localCache, Date)) {
              expire = getCacheExpireTs(_localCache);
          }
          else {
              const { mode = MEMORY, expire: configExpire = 0, tag: configTag } = _localCache || {};
              cacheMode = mode;
              expire = getCacheExpireTs(configExpire);
              storage = [STORAGE_PLACEHOLDER, STORAGE_RESTORE].includes(mode);
              tag = configTag ? configTag.toString() : undefinedValue;
          }
      }
      return {
          e: expire,
          m: cacheMode,
          s: storage,
          t: tag
      };
  };
  /**
   * 获取请求方法对象
   * @param methodHandler 请求方法句柄
   * @param args 方法调用参数
   * @returns 请求方法对象
   */
  const getHandlerMethod = (methodHandler, args = []) => (isFn(methodHandler) ? methodHandler(...args) : methodHandler);
  /**
   * 统一配置
   * @param 数据
   * @returns 统一的配置
   */
  const sloughConfig = (config, args = []) => isFn(config) ? config(...args) : config;
  /**
   * 判断target是否为Promise，如果是则直接返回promise对象，否则返回Promise.resolve(target)包装成promise
   * @param target 目标数据
   * @returns {Promise<any>}
   */
  const promisify = (target) => instanceOf(target, PromiseCls) ? target : promiseResolve(target);
  /**
   * 创建类实例
   * @param cls 构造函数
   * @param args 构造函数参数
   * @returns 类实例
   */
  const newInstance = (cls, ...args) => new cls(...args);

  /** method实例快照集合，发送过请求的method实例将会被保存 */
  const methodSnapshots = {};
  /**
   * 保存method实例快照
   * @param namespace 命名空间
   * @param methodInstance method实例
   */
  const saveMethodSnapshot = (namespace, key, methodInstance) => {
      const namespacedSnapshots = (methodSnapshots[namespace] = methodSnapshots[namespace] || {});
      namespacedSnapshots[key] = methodInstance;
  };
  /**
   * 获取Method实例快照，它将根据matcher来筛选出对应的Method实例
   * @param matcher 匹配的快照名称，可以是字符串或正则表达式、或带过滤函数的对象
   * @returns 匹配到的Method实例快照数组
   */
  const matchSnapshotMethod = (matcher, matchAll = trueValue) => {
      // 将filter参数统一解构为nameMatcher和matchHandler
      let namespace = '';
      let nameMatcher = undefinedValue;
      let matchHandler;
      if (isString(matcher) || instanceOf(matcher, RegExp)) {
          nameMatcher = matcher;
      }
      else if (isPlainObject(matcher)) {
          nameMatcher = matcher.name;
          matchHandler = matcher.filter;
          const alova = matcher.alova;
          namespace = alova ? alova.id : namespace;
      }
      // 通过解构的nameMatcher和filterHandler，获取对应的Method实例快照
      const matches = [];
      // 如果有提供namespace参数则只在这个namespace中查找，否则在所有缓存数据中查找
      forEach(objectKeys(methodSnapshots), keyedNamespace => {
          if (!namespace || keyedNamespace === namespace) {
              const namespacedSnapshots = methodSnapshots[keyedNamespace];
              forEach(objectKeys(namespacedSnapshots), methodKey => {
                  // 为做到和缓存表现统一，如果过期了则不匹配出来，并删除其缓存
                  const hitMethodInstance = namespacedSnapshots[methodKey];
                  const name = getConfig(hitMethodInstance).name || '';
                  // 当nameMatcher为undefined时，表示命中所有method实例
                  if (nameMatcher === undefinedValue ||
                      (instanceOf(nameMatcher, RegExp) ? nameMatcher.test(name) : name === nameMatcher)) {
                      // 在外部需要使用原始的key，而不是实时生成key
                      // 原因是，method的参数可能传入引用类型值，但引用类型值在外部改变时，实时生成的key也随之改变，因此使用最开始的key更准确
                      hitMethodInstance.__key__ = methodKey;
                      pushItem(matches, hitMethodInstance);
                  }
              });
          }
      });
      return (matchHandler ? matches[matchAll ? 'filter' : 'find'](matchHandler) : matchAll ? matches : matches[0]);
  };
  /**
   *
   * @param matcher Method实例匹配器
   * @param matchAll 是否匹配全部method实例
   * @returns
   */
  const filterSnapshotMethods = (matcher, matchAll) => {
      let methods;
      if (isArray(matcher)) {
          methods = matcher;
      }
      else if (matcher && isString(matcher.url)) {
          methods = matchAll ? [matcher] : matcher;
      }
      else {
          methods = matchSnapshotMethod(matcher, matchAll);
      }
      return methods;
  };

  // 响应数据缓存
  let responseCache = {};
  /**
   * 检查给定时间是否过期，如果没有过期时间则表示数据永不过期，否则需要判断是否过期
   * @param expireTime 过期时间
   * @returns 是否过期
   */
  const isExpired = (expireTime) => expireTime < getTime();
  /**
   * @description 获取Response缓存数据
   * @param baseURL 基础URL
   * @param key 请求key值
   * @returns 缓存的响应数据，如果没有则返回undefined
   */
  const getResponseCache = (namespace, key) => {
      const cachedResponse = responseCache[namespace];
      if (cachedResponse) {
          const cachedItem = cachedResponse[key];
          if (cachedItem) {
              if (!isExpired(cachedItem[1])) {
                  return cachedItem[0];
              }
              // 如果过期，则删除缓存
              deleteAttr(cachedResponse, key);
          }
      }
  };
  /**
   * @description 设置Response缓存数据
   * @param baseURL 基础URL
   * @param key 请求key值
   * @param data 缓存数据
   * @param methodInstance method实例
   * @param expireTimestamp 过期时间戳，单位毫秒
   */
  const setResponseCache = (namespace, key, data, expireTimestamp = 0) => {
      if (expireTimestamp > getTime() && data) {
          const cachedResponse = (responseCache[namespace] = responseCache[namespace] || {});
          cachedResponse[key] = [data, expireTimestamp];
      }
  };
  /**
   * @description 清除Response缓存数据
   * @param baseURL 基础URL
   * @param key 请求key值
   */
  const removeResponseCache = (namespace, key) => {
      const cachedResponse = responseCache[namespace];
      cachedResponse && deleteAttr(cachedResponse, key);
  };
  /**
   * @description 清空Response缓存数据
   */
  const clearResponseCache = () => {
      responseCache = {};
  };

  const responseStorageKey = 'alova.';
  const buildNamespacedStorageKey = (namespace, key) => responseStorageKey + namespace + key;
  /**
   * 持久化响应数据
   * @param namespace 命名空间
   * @param key 存储的key
   * @param response 存储的响应内容
   * @param expireTimestamp 过期时间点的时间戳表示
   * @param storage 存储对象
   * @param tag 存储标签，用于区分不同的存储标记
   */
  const persistResponse = (namespace, key, response, expireTimestamp, storage, tag = nullValue) => {
      // 小于0则不持久化了
      if (expireTimestamp > 0 && response) {
          storage.set(buildNamespacedStorageKey(namespace, key), [
              response,
              expireTimestamp === Infinity ? nullValue : expireTimestamp,
              tag
          ]);
      }
  };
  /**
   * 获取存储的响应数据
   * @param namespace 命名空间
   * @param key 存储的key
   * @param storage 存储对象
   * @param tag 存储标签，标记改变了数据将会失效
   */
  const getPersistentResponse = (namespace, key, storage, tag = null) => {
      const storagedData = storage.get(buildNamespacedStorageKey(namespace, key));
      if (storagedData) {
          const [response, expireTimestamp, storedTag = nullValue] = storagedData;
          // 如果没有过期时间则表示数据永不过期，否则需要判断是否过期
          if (storedTag === tag && (!expireTimestamp || expireTimestamp > getTime())) {
              return response;
          }
          // 如果过期，则删除缓存
          removePersistentResponse(namespace, key, storage);
      }
  };
  /**
   * 删除存储的响应数据
   * @param namespace 命名空间
   * @param key 存储的key
   * @param storage 存储对象
   */
  const removePersistentResponse = (namespace, key, storage) => {
      storage.remove(buildNamespacedStorageKey(namespace, key));
  };

  var cloneMethod = (methodInstance) => {
      const { data, config } = methodInstance;
      const newConfig = { ...config };
      const { headers = {}, params = {} } = newConfig;
      newConfig.headers = { ...headers };
      newConfig.params = { ...params };
      const clonedMethod = newInstance((Method), methodInstance.type, getContext(methodInstance), methodInstance.url, newConfig, data);
      return clonedMethod;
  };

  /*
   * 以下三个函数中的matcher为Method实例匹配器，它分为3种情况：
   * 1. 如果matcher为Method实例，则清空该Method实例缓存
   * 2. 如果matcher为字符串或正则，则清空所有符合条件的Method实例缓存
   * 3. 如果未传入matcher，则会清空所有缓存
   */
  /**
   * 查询缓存
   * @param matcher Method实例匹配器
   * @returns 缓存数据，未查到时返回undefined
   */
  const queryCache = (matcher) => {
      const methodInstance = filterSnapshotMethods(matcher, falseValue);
      if (methodInstance) {
          const { id, storage } = getContext(methodInstance);
          const methodKey = methodInstance.__key__ || key(methodInstance);
          return (getResponseCache(id, methodKey) ||
              getPersistentResponse(id, methodKey, storage, getLocalCacheConfigParam(methodInstance).t));
      }
  };
  /**
   * 手动设置缓存响应数据，如果对应的methodInstance设置了持久化存储，则还会去检出持久化存储中的缓存
   * @param matcher Method实例匹配器
   * @param data 缓存数据
   */
  const setCache = (matcher, dataOrUpdater) => {
      const methodInstances = filterSnapshotMethods(matcher, trueValue);
      forEach(methodInstances, methodInstance => {
          const { id, storage } = getContext(methodInstance);
          const methodKey = methodInstance.__key__ || key(methodInstance);
          const { e: expireMilliseconds, s: toStorage, t: tag } = getLocalCacheConfigParam(methodInstance);
          let data = dataOrUpdater;
          if (isFn(dataOrUpdater)) {
              const cachedData = getResponseCache(id, methodKey) || getPersistentResponse(id, methodKey, storage, tag);
              data = dataOrUpdater(cachedData);
              if (data === undefinedValue) {
                  return;
              }
          }
          setResponseCache(id, methodKey, data, expireMilliseconds);
          toStorage && persistResponse(id, methodKey, data, expireMilliseconds, storage, tag);
      });
  };
  /**
   * 失效缓存
   * @param matcher Method实例匹配器
   */
  const invalidateCache = (matcher) => {
      if (!matcher) {
          clearResponseCache();
          return;
      }
      const methodInstances = filterSnapshotMethods(matcher, trueValue);
      forEach(methodInstances, methodInstance => {
          const { id, storage } = getContext(methodInstance);
          const methodKey = methodInstance.__key__ || key(methodInstance);
          removeResponseCache(id, methodKey);
          removePersistentResponse(id, methodKey, storage);
      });
  };

  const adapterReturnMap = {};
  /**
   * 构建完整的url
   * @param base baseURL
   * @param url 路径
   * @param params url参数
   * @returns 完整的url
   */
  const buildCompletedURL = (baseURL, url, params) => {
      // baseURL如果以/结尾，则去掉/
      baseURL = baseURL.endsWith('/') ? baseURL.slice(0, -1) : baseURL;
      // 如果不是/或http协议开头的，则需要添加/
      url = url.match(/^(\/|https?:\/\/)/) ? url : `/${url}`;
      const completeURL = baseURL + url;
      // 将params对象转换为get字符串
      // 过滤掉值为undefined的
      const paramsStr = objectKeys(params)
          .filter(key => params[key] !== undefinedValue)
          .map(key => `${key}=${params[key]}`)
          .join('&');
      // 将get参数拼接到url后面，注意url可能已存在参数
      return paramsStr
          ? +completeURL.includes('?')
              ? `${completeURL}&${paramsStr}`
              : `${completeURL}?${paramsStr}`
          : completeURL;
  };
  /**
   * 实际的请求函数
   * @param method 请求方法对象
   * @param forceRequest 忽略缓存
   * @returns 响应数据
   */
  function sendRequest(methodInstance, forceRequest) {
      let requestAdapterCtrls = undefinedValue;
      let fromCache = trueValue;
      const response = () => {
          const { beforeRequest = noop, responsed, responded, requestAdapter } = getOptions(methodInstance);
          // 使用克隆之前的method key，以免在beforeRequest中method被改动而导致method key改变
          // method key在beforeRequest中被改变将会致使使用method 实例操作缓存时匹配失败
          const methodKey = key(methodInstance);
          const clonedMethod = cloneMethod(methodInstance);
          // 发送请求前调用钩子函数
          // beforeRequest支持同步函数和异步函数
          return promisify(beforeRequest(clonedMethod))
              .then(() => {
              // 获取受控缓存或非受控缓存
              const { localCache } = getConfig(clonedMethod);
              // 如果当前method设置了受控缓存，则看是否有自定义的数据
              if (isFn(localCache)) {
                  return localCache();
              }
              // 如果是强制请求的，则跳过从缓存中获取的步骤
              // 否则判断是否使用缓存数据
              if (!forceRequest) {
                  const cachedResp = getResponseCache(getContext(clonedMethod).id, methodKey);
                  if (cachedResp) {
                      return cachedResp;
                  }
              }
          })
              .then(cachedResponse => {
              // 如果没有缓存则发起请求
              if (cachedResponse !== undefinedValue) {
                  return cachedResponse;
              }
              const { baseURL, url: newUrl, type, data } = clonedMethod;
              const { id, storage } = getContext(clonedMethod);
              const { params = {}, headers = {}, transformData = _self, name: methodInstanceName = '', shareRequest } = getConfig(clonedMethod);
              fromCache = falseValue;
              const { e: expireTimestamp, s: toStorage, t: tag } = getLocalCacheConfigParam(clonedMethod);
              const namespacedAdapterReturnMap = (adapterReturnMap[id] = adapterReturnMap[id] || {});
              requestAdapterCtrls = namespacedAdapterReturnMap[methodKey];
              if (!shareRequest || !requestAdapterCtrls) {
                  // 请求数据
                  const ctrls = requestAdapter({
                      url: buildCompletedURL(baseURL, newUrl, params),
                      type,
                      data,
                      headers
                  }, clonedMethod);
                  requestAdapterCtrls = namespacedAdapterReturnMap[methodKey] = ctrls;
              }
              let responseHandler = _self;
              let responseErrorHandler = undefinedValue;
              // responsed是一个错误的单词，正确的单词是responded
              // 在2.1.0+添加了responded的支持，并和responsed做了兼容处理
              // 计划将在3.0中正式使用responded
              const responseUnified = responded || responsed;
              if (isFn(responseUnified)) {
                  responseHandler = responseUnified;
              }
              else if (isPlainObject(responseUnified)) {
                  const { onSuccess: successHandler, onError: errorHandler } = responseUnified;
                  responseHandler = isFn(successHandler) ? successHandler : responseHandler;
                  responseErrorHandler = isFn(errorHandler) ? errorHandler : responseErrorHandler;
              }
              return (PromiseCls.all([requestAdapterCtrls.response(), requestAdapterCtrls.headers()])
                  .then(([rawResponse, headers]) => promisify(responseHandler(rawResponse, clonedMethod))
                  .then(data => transformData(data, headers))
                  .then(transformedData => {
                  saveMethodSnapshot(id, methodKey, methodInstance);
                  // 当requestBody为特殊数据时不保存缓存
                  // 原因1：特殊数据一般是提交特殊数据，需要和服务端交互
                  // 原因2：特殊数据不便于生成缓存key
                  const requestBody = clonedMethod.data;
                  const toCache = !requestBody || !isSpecialRequestBody(requestBody);
                  if (toCache) {
                      setResponseCache(id, methodKey, transformedData, expireTimestamp);
                      toStorage && persistResponse(id, methodKey, transformedData, expireTimestamp, storage, tag);
                  }
                  // 查找hitTarget，让它的缓存失效
                  const hitMethods = matchSnapshotMethod({
                      filter: cachedMethod => {
                          let isHit = falseValue;
                          const hitSource = cachedMethod.hitSource;
                          if (hitSource) {
                              for (const i in hitSource) {
                                  const sourceMatcher = hitSource[i];
                                  if (instanceOf(sourceMatcher, RegExp)
                                      ? sourceMatcher.test(methodInstanceName)
                                      : sourceMatcher === methodInstanceName || sourceMatcher === methodKey) {
                                      isHit = trueValue;
                                      break;
                                  }
                              }
                          }
                          return isHit;
                      }
                  });
                  len(hitMethods) > 0 && invalidateCache(hitMethods);
                  return transformedData;
              }), (error) => {
                  if (!isFn(responseErrorHandler)) {
                      throw error;
                  }
                  // 可能返回Promise.reject
                  return responseErrorHandler(error, clonedMethod);
              })
                  // 请求成功、失败，以及在成功后处理报错，都需要移除共享的请求
                  .finally(() => deleteAttr(namespacedAdapterReturnMap, methodKey)));
          });
      };
      return {
          abort: () => requestAdapterCtrls && requestAdapterCtrls.abort(),
          onDownload: (handler) => requestAdapterCtrls && requestAdapterCtrls.onDownload && requestAdapterCtrls.onDownload(handler),
          onUpload: (handler) => requestAdapterCtrls && requestAdapterCtrls.onUpload && requestAdapterCtrls.onUpload(handler),
          response,
          fromCache: () => fromCache
      };
  }

  const typeGet = 'GET';
  const typeHead = 'HEAD';
  const typePost = 'POST';
  const typePut = 'PUT';
  const typePatch = 'PATCH';
  const typeDelete = 'DELETE';
  const typeOptions = 'OPTIONS';
  class Method {
      constructor(type, context, url, config, data) {
          const contextOptions = getContextOptions(context);
          this.baseURL = contextOptions.baseURL || '';
          this.url = url;
          this.type = type;
          this.context = context;
          // 将请求相关的全局配置合并到Method对象中
          const contextConcatConfig = {};
          // 合并参数
          forEach(['timeout', 'shareRequest'], mergedKey => {
              if (contextOptions[mergedKey] !== undefinedValue) {
                  contextConcatConfig[mergedKey] = contextOptions[mergedKey];
              }
          });
          // 合并localCache
          const mergedLocalCacheKey = 'localCache';
          const globalLocalCache = isPlainObject(contextOptions[mergedLocalCacheKey])
              ? contextOptions[mergedLocalCacheKey][type]
              : undefinedValue;
          if (globalLocalCache !== undefinedValue) {
              contextConcatConfig[mergedLocalCacheKey] = globalLocalCache;
          }
          // 将hitSource统一处理成数组，且当有method实例时将它们转换为methodKey
          const hitSource = config === null || config === void 0 ? void 0 : config.hitSource;
          if (hitSource) {
              this.hitSource = (isArray(hitSource) ? hitSource : [hitSource]).map(sourceItem => instanceOf(sourceItem, Method) ? key(sourceItem) : sourceItem);
              deleteAttr(config, 'hitSource');
          }
          this.config = {
              ...contextConcatConfig,
              headers: {},
              params: {},
              ...(config || {})
          };
          this.data = data;
      }
      /**
       * 直接发出请求，返回promise对象
       */
      send(forceRequest = falseValue) {
          return sendRequest(this, forceRequest).response();
      }
      /**
       * 设置方法名称，如果已有名称将被覆盖
       * @param name 方法名称
       */
      setName(name) {
          getConfig(this).name = name;
      }
  }

  /**
   * 创建默认的localStorage存储适配器
   */
  const session = {};
  const sessionStorage = {
      getItem: (key) => session[key],
      setItem: (key, value) => (session[key] = value),
      removeItem: (key) => deleteAttr(session, key)
  };
  var globalLocalStorage = () => {
      const storage = isSSR ? sessionStorage : window.localStorage;
      return {
          set: (key, value) => storage.setItem(key, JSONStringify(value)),
          get: key => {
              const data = storage.getItem(key);
              return data ? JSONParse(data) : data;
          },
          remove: key => storage.removeItem(key)
      };
  };

  const alovas = [];
  const defaultAlovaOptions = {
      /**
       * GET请求默认缓存5分钟（300000毫秒），其他请求默认不缓存
       */
      localCache: {
          [typeGet]: 300000
      },
      /**
       * 共享请求默认为true
       */
      shareRequest: trueValue
  };
  let idCounter = 0;
  class Alova {
      constructor(options) {
          this.id = ++idCounter + '';
          // 如果storage未指定，则默认使用localStorage
          this.storage = options.storageAdapter || globalLocalStorage();
          // 合并默认options
          this.options = {
              ...defaultAlovaOptions,
              ...options
          };
      }
      Get(url, config) {
          return newInstance((Method), typeGet, this, url, config);
      }
      Post(url, data = {}, config) {
          return newInstance((Method), typePost, this, url, config, data);
      }
      Delete(url, data = {}, config) {
          return newInstance((Method), typeDelete, this, url, config, data);
      }
      Put(url, data = {}, config) {
          return newInstance((Method), typePut, this, url, config, data);
      }
      Head(url, config) {
          return newInstance((Method), typeHead, this, url, config);
      }
      Patch(url, data = {}, config) {
          return newInstance((Method), typePatch, this, url, config, data);
      }
      Options(url, config) {
          return newInstance((Method), typeOptions, this, url, config);
      }
  }

  /**
   * 创建一个Alova错误对象
   * @param msg 错误消息
   * @returns 错误对象
   */
  var alovaError = (msg, code) => {
      const err = newInstance(Error, `[alova]${msg}`);
      code && (err.name = code);
      return err;
  };

  /**
   * 自定义断言函数，表达式为false时抛出错误
   * @param expression 判断表达式，true或false
   * @param msg 断言消息
   */
  function myAssert(expression, msg) {
      if (!expression) {
          throw alovaError(msg);
      }
  }
  /**
   * 断言是否创建了alova实例
   */
  function assertAlovaCreation() {
      myAssert(len(alovas) > 0, 'please create a alova instance first.');
  }

  // 状态数据缓存
  const stateCache = {};
  /**
   * @description 获取State缓存数据
   * @param baseURL 基础URL
   * @param key 请求key值
   * @returns 缓存的响应数据，如果没有则返回undefined
   */
  const getStateCache = (namespace, key) => {
      const cachedState = stateCache[namespace];
      if (!cachedState) {
          return undefinedValue;
      }
      return cachedState[key];
  };
  /**
   * @description 设置State缓存数据
   * @param baseURL 基础URL
   * @param key 请求key值
   * @param data 缓存数据
   */
  const setStateCache = (namespace, key, data) => {
      const cachedState = (stateCache[namespace] = stateCache[namespace] || {});
      cachedState[key] = data;
  };
  /**
   * @description 清除State缓存数据
   * @param baseURL 基础URL
   * @param key 请求key值
   */
  const removeStateCache = (namespace, key) => {
      const cachedState = stateCache[namespace];
      if (cachedState) {
          deleteAttr(cachedState, key);
      }
  };

  /**
   * 更新对应method的状态
   * @param method 请求方法对象
   * @param handleUpdate 更新回调
   * @returns 是否更新成功，未找到对应的状态时不会更新成功
   */
  function updateState(matcher, handleUpdate, options = {}) {
      const { onMatch = noop } = options;
      const methodInstance = filterSnapshotMethods(matcher, falseValue);
      let updated = falseValue;
      // 只处理符合条件的第一个Method实例，如果没有符合条件的实例，则不处理
      if (methodInstance) {
          onMatch(methodInstance); // 触发onMatch事件
          const { statesHook: { dehydrate, update } } = getOptions(methodInstance);
          const methodKey = methodInstance.__key__ || key(methodInstance);
          const { id, storage } = getContext(methodInstance);
          const frontStates = getStateCache(id, methodKey);
          if (frontStates) {
              const { e: expireMilliseconds, s: toStorage, t: tag } = getLocalCacheConfigParam(methodInstance);
              const updateStateCollection = isFn(handleUpdate)
                  ? { data: handleUpdate }
                  : handleUpdate;
              // 循环遍历更新数据，并赋值给受监管的状态
              forEach(objectKeys(updateStateCollection), stateName => {
                  myAssert(frontStates[stateName] !== undefinedValue, `can not find state named \`${stateName}\``);
                  myAssert(!objectKeys(frontStates).slice(-4).includes(stateName), 'can not update preset states');
                  try {
                      const updatedData = updateStateCollection[stateName](dehydrate(frontStates[stateName]));
                      update({
                          [stateName]: updatedData
                      }, frontStates);
                      // 同时需要更新缓存和持久化数据
                      setResponseCache(id, methodKey, updatedData, expireMilliseconds);
                      toStorage && persistResponse(id, methodKey, updatedData, expireMilliseconds, storage, tag);
                  }
                  catch (e) {
                      throw alovaError(`managed state \`${stateName}\` must be a state.`);
                  }
              });
              updated = trueValue;
          }
      }
      return updated;
  }

  const defaultMiddleware = (_, next) => next();
  var defaultMiddleware$1 = defaultMiddleware;

  /**
   * 创建统一的事件对象
   *
   */
  var createAlovaEvent = (eventType, method, sendArgs, fromCache, data, error, status) => {
      const allPropsEvent = {
          /** 事件对应的请求行为 */
          /** 当前的method实例 */
          method,
          /** 通过send触发请求时传入的参数 */
          sendArgs,
          /** 响应数据，只在成功时有值 */
          data,
          /** 失败时抛出的错误，只在失败时有值 */
          error,
          /** 请求状态 */
          status,
          /** data数据是否来自缓存，当status为error时，fromCache始终为false */
          fromCache
      };
      const eventInstance = {};
      forEach(objectKeys(allPropsEvent), key => {
          allPropsEvent[key] !== undefinedValue &&
              (eventInstance[key] = allPropsEvent[key]);
      });
      // 将此类的对象重新命名，让它看上去是由不同的类生成的对象
      // 以此来对应typescript中定义的类型
      const typeName = ['AlovaSuccessEvent', 'AlovaErrorEvent', 'AlovaCompleteEvent'][eventType];
      typeName &&
          ObjectCls.defineProperty(eventInstance, Symbol.toStringTag, {
              value: typeName
          });
      return eventInstance;
  };

  /**
   * 统一处理useRequest/useWatcher/useController等请求钩子函数的请求逻辑
   * @param methodInstance 请求方法对象
   * @param frontStates 前端状态集合
   * @param useHookConfig useHook配置对象
   * @param successHandlers 成功回调
   * @param errorHandlers 失败回调
   * @param completeHandlers 完成回调
   * @param sendArgs send函数参数
   * @param updateCacheState 是否更新缓存状态，一般在useFetcher时设置为true
   * @returns 请求状态
   */
  function useHookToSendRequest(methodInstance, frontStates, useHookConfig, successHandlers, errorHandlers, completeHandlers, sendArgs = [], updateCacheState = falseValue) {
      const { force: forceRequest = falseValue, middleware = defaultMiddleware$1 } = useHookConfig;
      const { id, options, storage } = getContext(methodInstance);
      const { update } = options.statesHook;
      // 如果是静默请求，则请求后直接调用onSuccess，不触发onError，然后也不会更新progress
      const methodKey = key(methodInstance);
      // 初始化状态数据，在拉取数据时不需要加载，因为拉取数据不需要返回data数据
      let removeStates = noop;
      let saveStates = noop;
      const { e: expireMilliseconds, m: cacheMode, t: tag } = getLocalCacheConfigParam(methodInstance);
      let cachedResponse = getResponseCache(id, methodKey);
      if (!updateCacheState) {
          // 当缓存模式为memory时不获取缓存，减少缓存获取
          const persistentResponse = cacheMode !== MEMORY ? getPersistentResponse(id, methodKey, storage, tag) : undefinedValue;
          // 如果有持久化数据，则需要判断是否需要恢复它到缓存中
          // 如果是STORAGE_RESTORE模式，且缓存没有数据时，则需要将持久化数据恢复到缓存中
          if (cacheMode === STORAGE_RESTORE && !cachedResponse && persistentResponse) {
              setResponseCache(id, methodKey, persistentResponse, expireMilliseconds);
              cachedResponse = persistentResponse;
          }
          // 如果命中持久化数据，则更新数据
          if (cachedResponse || persistentResponse) {
              update({
                  data: cachedResponse || persistentResponse
              }, frontStates);
          }
          // 将初始状态存入缓存以便后续更新
          saveStates = (frontStates) => setStateCache(id, methodKey, frontStates);
          saveStates(frontStates);
          // 设置状态移除函数，将会传递给hook内的effectRequest，它将被设置在组件卸载时调用
          removeStates = () => removeStateCache(id, methodKey);
      }
      let requestCtrl = {};
      let responseHandlePromise = promiseResolve(undefinedValue);
      let fromCache = () => !!cachedResponse;
      // 中间件函数next回调函数，允许修改强制请求参数，甚至替换即将发送请求的Method实例
      const guardNext = guardNextConfig => {
          const { force: guardNextForceRequest = forceRequest, method: guardNextReplacingMethod = methodInstance } = guardNextConfig || {};
          const forceRequestFinally = sloughConfig(guardNextForceRequest, sendArgs);
          const { response, onDownload = noop, onUpload = noop, fromCache: getFromCacheValue } = (requestCtrl = sendRequest(guardNextReplacingMethod, forceRequestFinally));
          fromCache = getFromCacheValue;
          // 命中缓存，或强制请求时需要更新loading状态
          if (forceRequestFinally || !cachedResponse) {
              update({
                  loading: trueValue
              }, frontStates);
          }
          responseHandlePromise = response();
          const progressUpdater = (stage) => (loaded, total) => {
              update({
                  [stage]: {
                      loaded,
                      total
                  }
              }, frontStates);
          };
          const { enableDownload, enableUpload } = getConfig(methodInstance);
          enableDownload && onDownload(progressUpdater('downloading'));
          enableUpload && onUpload(progressUpdater('uploading'));
          return responseHandlePromise;
      };
      // 调用中间件函数
      let successHandlerDecorator;
      let errorHandlerDecorator;
      let completeHandlerDecorator;
      const middlewareCompletePromise = middleware({
          method: methodInstance,
          cachedResponse,
          sendArgs,
          config: useHookConfig,
          frontStates,
          update: newFrontStates => update(newFrontStates, frontStates),
          decorateSuccess: (decorator) => {
              isFn(decorator) && (successHandlerDecorator = decorator);
          },
          decorateError: (decorator) => {
              isFn(decorator) && (errorHandlerDecorator = decorator);
          },
          decorateComplete: (decorator) => {
              isFn(decorator) && (completeHandlerDecorator = decorator);
          }
      }, guardNext);
      myAssert(instanceOf(middlewareCompletePromise, PromiseCls), 'middleware must be a async function');
      const isNextCalled = () => len(objectKeys(requestCtrl)) > 0;
      const runArgsHandler = (handlers, decorator, event) => {
          forEach(handlers, (handler, index) => isFn(decorator) ? decorator(handler, event, index, len(handlers)) : handler(event));
      };
      // 统一处理响应
      const responseCompletePromise = promiseCatch(promiseThen(middlewareCompletePromise, middlewareReturnedData => {
          const afterSuccess = (data) => {
              // 更新缓存响应数据
              if (!updateCacheState) {
                  update({ data }, frontStates);
              }
              else {
                  // 更新缓存内的状态，一般为useFetcher中进入
                  const cachedState = getStateCache(id, methodKey);
                  cachedState && update({ data }, cachedState);
              }
              // 在请求后触发对应回调函数，静默请求在请求前已经触发过回调函数了
              update({ loading: falseValue }, frontStates);
              runArgsHandler(successHandlers, successHandlerDecorator, createAlovaEvent(0, methodInstance, sendArgs, fromCache(), data));
              runArgsHandler(completeHandlers, completeHandlerDecorator, createAlovaEvent(2, methodInstance, sendArgs, fromCache(), data, undefinedValue, 'success'));
              return data;
          };
          // 中间件中未返回数据或返回undefined时，去获取真实的响应数据
          // 否则使用返回数据并不再等待响应promise，此时也需要调用响应回调
          if (middlewareReturnedData !== undefinedValue) {
              return afterSuccess(middlewareReturnedData);
          }
          if (!isNextCalled()) {
              return;
          }
          // 当middlewareCompletePromise为resolve时有两种可能
          // 1. 请求正常
          // 2. 请求错误，但错误被中间件函数捕获了，此时也将调用成功回调，即afterSuccess(undefinedValue)
          return promiseThen(responseHandlePromise, afterSuccess, () => afterSuccess(undefinedValue));
      }), 
      // catch回调函数
      (error) => {
          // 静默请求下，失败了的话则将请求信息保存到缓存，并开启循环调用请求
          update({
              error,
              loading: falseValue
          }, frontStates);
          runArgsHandler(errorHandlers, errorHandlerDecorator, createAlovaEvent(1, methodInstance, sendArgs, fromCache(), undefinedValue, error));
          runArgsHandler(completeHandlers, completeHandlerDecorator, createAlovaEvent(2, methodInstance, sendArgs, fromCache(), undefinedValue, error, 'error'));
          return promiseReject(error);
      });
      return {
          ...requestCtrl,
          p: responseCompletePromise,
          r: removeStates,
          s: saveStates
      };
  }

  /**
   * 创建请求状态，统一处理useRequest、useWatcher、useEffectWatcher中一致的逻辑
   * 该函数会调用statesHook的创建函数来创建对应的请求状态
   * 当该值为空时，表示useFetcher进入的，此时不需要data状态和缓存状态
   * @param method 请求方法对象
   * @param handleRequest 请求处理的回调函数
   * @param methodKey 请求方法的key
   * @param watchingStates 被监听的状态，如果未传入，直接调用handleRequest
   * @param immediate 是否立即发起请求
   * @param debounceDelay 请求发起的延迟时间
   * @returns 当前的请求状态
   */
  function createRequestState(alovaInstance, methodHandler, useHookConfig, initialData, immediate = falseValue, watchingStates, debounceDelay = 0) {
      const { create, export: stateExport, effectRequest, update } = getStatesHook(alovaInstance);
      const progress = {
          total: 0,
          loaded: 0
      };
      // 将外部传入的受监管的状态一同放到frontStates集合中
      const { managedStates = {} } = useHookConfig;
      const frontStates = {
          ...managedStates,
          data: create(initialData),
          loading: create(falseValue),
          error: create(undefinedValue),
          downloading: create({ ...progress }),
          uploading: create({ ...progress })
      };
      // 请求事件
      const successHandlers = [];
      const errorHandlers = [];
      const completeHandlers = [];
      let abortFn = undefinedValue;
      let removeStatesFn = noop;
      let saveStatesFn = noop;
      const hasWatchingStates = watchingStates !== undefinedValue;
      // 统一处理请求发送
      const handleRequest = (methodInstance, useHookConfigParam = useHookConfig, sendCallingArgs, updateCacheState) => {
          const { abort, p: responseHandlePromise, r: removeStates, s: saveStates } = useHookToSendRequest(methodInstance, frontStates, useHookConfigParam, successHandlers, errorHandlers, completeHandlers, sendCallingArgs, updateCacheState);
          // 每次发送请求都需要保存最新的控制器
          abortFn = abort;
          removeStatesFn = removeStates;
          saveStatesFn = saveStates;
          return responseHandlePromise;
      };
      // 调用请求处理回调函数
      const wrapEffectRequest = () => {
          // 此参数是在send中使用的，在这边需要捕获异常，避免异常继续往外跑
          const methodInstance = getHandlerMethod(methodHandler);
          promiseCatch(handleRequest(methodInstance), noop);
      };
      effectRequest({
          handler: 
          // watchingStates为数组时表示监听状态（包含空数组），为undefined时表示不监听状态
          hasWatchingStates
              ? debounce(wrapEffectRequest, (changedIndex) => isNumber(changedIndex) ? (isArray(debounceDelay) ? debounceDelay[changedIndex] : debounceDelay) : 0)
              : wrapEffectRequest,
          removeStates: () => removeStatesFn(),
          saveStates: (states) => saveStatesFn(states),
          frontStates: frontStates,
          watchingStates,
          immediate: immediate !== null && immediate !== void 0 ? immediate : trueValue
      });
      const exportedStates = {
          loading: stateExport(frontStates.loading),
          data: stateExport(frontStates.data),
          error: stateExport(frontStates.error),
          downloading: stateExport(frontStates.downloading),
          uploading: stateExport(frontStates.uploading)
      };
      return {
          ...exportedStates,
          onSuccess(handler) {
              pushItem(successHandlers, handler);
          },
          onError(handler) {
              pushItem(errorHandlers, handler);
          },
          onComplete(handler) {
              pushItem(completeHandlers, handler);
          },
          update(newFrontStates) {
              update(newFrontStates, frontStates);
          },
          abort: () => (abortFn || noop)(),
          /**
           * 通过执行该方法来手动发起请求
           * @param methodInstance 方法对象
           * @param useHookConfig useHook配置参数对象
           * @param sendCallingArgs 调用send函数时传入的参数
           * @param updateCacheState 是否更新缓存状态，此为fetch传入
           * @returns 请求promise
           */
          send(sendCallingArgs, methodInstance, updateCacheState) {
              return handleRequest(methodInstance || getHandlerMethod(methodHandler, sendCallingArgs), useHookConfig, sendCallingArgs, updateCacheState);
          }
      };
  }

  /**
   * 获取请求数据并缓存
   * @param method 请求方法对象
   */
  function useFetcher(config = {}) {
      assertAlovaCreation();
      const props = createRequestState(alovas[0], noop, config);
      return {
          fetching: props.loading,
          error: props.error,
          downloading: props.downloading,
          uploading: props.uploading,
          onSuccess: props.onSuccess,
          onError: props.onError,
          onComplete: props.onComplete,
          abort: props.abort,
          /**
           * 拉取数据
           * fetch一定会发送请求，且如果当前请求的数据有管理对应的状态，则会更新这个状态
           * @param matcher Method对象匹配器
           */
          fetch: (matcher, ...args) => {
              const methodInstance = filterSnapshotMethods(matcher, falseValue);
              myAssert(!!methodInstance, 'method instance is not found');
              props.send(args, methodInstance, trueValue);
          }
      };
  }

  function useRequest(handler, config = {}) {
      assertAlovaCreation();
      const { immediate = trueValue, initialData } = config;
      const props = createRequestState(alovas[0], handler, config, initialData, !!immediate);
      return {
          ...props,
          send: (...args) => props.send(args)
      };
  }

  function useWatcher(handler, watchingStates, config = {}) {
      myAssert(watchingStates && len(watchingStates) > 0, 'must specify at least one watching state');
      assertAlovaCreation();
      const { immediate, debounce = 0, initialData } = config;
      const props = createRequestState(alovas[0], handler, config, initialData, !!immediate, // !!immediate可以使immediate为falsy值时传入false，即不立即发送请求
      watchingStates, debounce);
      return {
          ...props,
          send: (...args) => props.send(args)
      };
  }

  /**
   * 创建Alova实例
   * @param options alova配置参数
   * @returns Alova实例
   */
  const createAlova = (options) => {
      const alovaInstance = newInstance((Alova), options);
      if (alovas[0]) {
          myAssert(getStatesHook(alovas[0]) === getStatesHook(alovaInstance), 'must use the same statesHook in one environment');
      }
      pushItem(alovas, alovaInstance);
      return alovaInstance;
  };
  /* c8 ignore start */
  {
      const consoleInfo = () => {
          console.log(`[alova tips]
-> Powerful request strategies: https://alova.js.org//category/strategy
-> Using mock data: https://alova.js.org/extension/alova-mock
-> Please give alova a star if you like it: https://github.com/alovajs/alova
-> This tips will remove in production environment. hide it in development: https://alova.js.org/others/hide-recommend-tips`);
      };
      try {
          // @ts-ignore
          if (undefined.VITE_ALOVA_TIPS !== '0') {
              consoleInfo();
          }
      }
      catch (e) { }
      try {
          if (process.env.VUE_APP_ALOVA_TIPS !== '0' && process.env.REACT_APP_ALOVA_TIPS !== '0') {
              consoleInfo();
          }
      }
      catch (e) { }
  }
  /* c8 ignore stop */

  exports.Method = Method;
  exports.createAlova = createAlova;
  exports.getMethodKey = key;
  exports.invalidateCache = invalidateCache;
  exports.matchSnapshotMethod = matchSnapshotMethod;
  exports.queryCache = queryCache;
  exports.setCache = setCache;
  exports.updateState = updateState;
  exports.useFetcher = useFetcher;
  exports.useRequest = useRequest;
  exports.useWatcher = useWatcher;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
