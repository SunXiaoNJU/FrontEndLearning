/**
  * alova 2.2.0 (https://alova.js.org)
  * Document https://alova.js.org
  * Copyright 2023 JOU-amjs. All Rights Reserved
  * Licensed under MIT (https://httpshub.com/alovajs/alova/blob/main/LICENSE)
  */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.GlobalFetch = factory());
})(this, (function () { 'use strict';

  // 以下为减少编译代码量而添加的统一处理函数或变量
  const PromiseCls = Promise, promiseReject = (value) => PromiseCls.reject(value), ObjectCls = Object, trueValue = true, falseValue = false, promiseThen = (promise, onFulfilled, onrejected) => promise.then(onFulfilled, onrejected), JSONStringify = (value) => JSON.stringify(value), setTimeoutFn = (fn, delay = 0) => setTimeout(fn, delay), clearTimeoutTimer = (timer) => clearTimeout(timer), len = (data) => data.length;

  /**
   * 判断参数是否为字符串
   * @param arg 任意参数
   * @returns 该参数是否为字符串
   */
  const isString = (arg) => typeof arg === 'string';
  /**
   * 全局的toString
   * @param arg 任意参数
   * @returns 字符串化的参数
   */
  const globalToString = (arg) => ObjectCls.prototype.toString.call(arg);
  /**
   * 判断是否为某个类的实例
   * @param arg 任意参数
   * @returns 判断结果
   */
  const instanceOf = (arg, cls) => arg instanceof cls;
  /**
   * 是否为特殊数据
   * @param data 提交数据
   * @returns 判断结果
   */
  const isSpecialRequestBody = (data) => {
      const dataTypeString = globalToString(data);
      return (/^\[object (Blob|FormData|ReadableStream|URLSearchParams)\]$/i.test(dataTypeString) || instanceOf(data, ArrayBuffer));
  };
  /**
   * 创建类实例
   * @param cls 构造函数
   * @param args 构造函数参数
   * @returns 类实例
   */
  const newInstance = (cls, ...args) => new cls(...args);

  /**
   * 创建一个Alova错误对象
   * @param msg 错误消息
   * @returns 错误对象
   */
  var alovaError = (msg, code) => {
      const err = newInstance(Error, `[alova]${msg}`);
      code && (err.name = code);
      return err;
  };

  const isBodyData = (data) => isString(data) || isSpecialRequestBody(data);
  function GlobalFetch() {
      return function (elements, method) {
          // 设置了中断时间，则在指定时间后中断请求
          const adapterConfig = method.config;
          const timeout = adapterConfig.timeout || 0;
          const ctrl = new AbortController();
          let abortTimer;
          let isTimeout = falseValue;
          if (timeout > 0) {
              abortTimer = setTimeoutFn(() => {
                  isTimeout = trueValue;
                  ctrl.abort();
              }, timeout);
          }
          const data = elements.data;
          const fetchPromise = fetch(elements.url, {
              ...adapterConfig,
              method: elements.type,
              signal: ctrl.signal,
              body: isBodyData(data) ? data : JSONStringify(data)
          });
          return {
              response: () => promiseThen(fetchPromise, response => {
                  // 请求成功后清除中断处理
                  clearTimeoutTimer(abortTimer);
                  // Response的Readable只能被读取一次，需要克隆才可重复使用
                  return response.clone();
              }, err => promiseReject(alovaError(isTimeout ? 'fetchError: network timeout' : err.message))),
              // headers函数内的then需捕获异常，否则会导致内部无法获取到正确的错误对象
              headers: () => promiseThen(fetchPromise, ({ headers }) => headers, () => ({})),
              // 因nodeFetch库限制，这块代码无法进行单元测试，但已在浏览器中通过测试
              /* c8 ignore start */
              onDownload: (cb) => {
                  promiseThen(fetchPromise, response => {
                      const { headers, body } = response.clone();
                      const reader = body === null || body === void 0 ? void 0 : body.getReader().read();
                      const total = Number(headers.get('Content-Length') || headers.get('content-length') || 0);
                      if (total <= 0) {
                          return;
                      }
                      let loaded = 0;
                      const progressTimer = setInterval(() => {
                          reader &&
                              promiseThen(reader, ({ done, value = new Uint8Array() }) => {
                                  done && clearInterval(progressTimer);
                                  loaded += len(value);
                                  cb(total, loaded);
                              });
                      }, 0);
                  });
              },
              /* c8 ignore start */
              abort: () => {
                  ctrl.abort();
                  clearTimeoutTimer(abortTimer);
              }
          };
      };
  }

  return GlobalFetch;

}));
