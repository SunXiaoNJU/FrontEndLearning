/**
  * alova 2.2.0 (https://alova.js.org)
  * Document https://alova.js.org
  * Copyright 2023 JOU-amjs. All Rights Reserved
  * Licensed under MIT (https://httpshub.com/alovajs/alova/blob/main/LICENSE)
  */

import { useState, useRef, useEffect, useCallback } from 'react';

// 以下为减少编译代码量而添加的统一处理函数或变量
const ObjectCls = Object, undefinedValue = undefined, trueValue = true, objectKeys = (obj) => ObjectCls.keys(obj), forEach = (ary, fn) => ary.forEach(fn);

const stateToData = ([state]) => state;
const refCurrent = (ref) => ref.current;
const setRef = (ref, newVal) => (ref.current = newVal);
// React的预定义hooks
var ReactHook = {
    create: (data) => useState(data),
    export: stateToData,
    dehydrate: stateToData,
    update: (newVal, states) => forEach(objectKeys(newVal), key => {
        states[key][1](newVal[key]);
    }),
    effectRequest({ handler, removeStates, saveStates, immediate, frontStates, watchingStates = [] }) {
        // 当有监听状态时，状态变化再触发
        const needEmit = useRef(immediate);
        const oldStates = watchingStates.map(s => useRef(s)); // 用于对比新旧值
        useEffect(() => {
            // 对比新旧状态，获取变化的状态索引
            let changedIndex = undefinedValue;
            forEach(watchingStates, (newState, i) => {
                if (!Object.is(refCurrent(oldStates[i]), newState)) {
                    changedIndex = i;
                    oldStates[i].current = newState;
                }
            });
            refCurrent(needEmit) ? handler(changedIndex) : setRef(needEmit, trueValue);
            return removeStates; // 组件卸载时移除对应状态
        }, watchingStates);
        // 因为react每次刷新都会重新调用usehook，因此每次会让状态缓存失效
        // 因此每次都需要更新管理的状态
        const needSave = useRef(false);
        const saveStatesFn = useCallback(saveStates, []);
        useEffect(() => {
            refCurrent(needSave) ? saveStatesFn(frontStates) : setRef(needSave, trueValue);
        });
    }
};

export { ReactHook as default };
