/**
  * alova 2.2.0 (https://alova.js.org)
  * Document https://alova.js.org
  * Copyright 2023 JOU-amjs. All Rights Reserved
  * Licensed under MIT (https://httpshub.com/alovajs/alova/blob/main/LICENSE)
  */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react')) :
  typeof define === 'function' && define.amd ? define(['react'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.ReactHook = factory(global.React));
})(this, (function (react) { 'use strict';

  // 以下为减少编译代码量而添加的统一处理函数或变量
  const ObjectCls = Object, undefinedValue = undefined, trueValue = true, objectKeys = (obj) => ObjectCls.keys(obj), forEach = (ary, fn) => ary.forEach(fn);

  const stateToData = ([state]) => state;
  const refCurrent = (ref) => ref.current;
  const setRef = (ref, newVal) => (ref.current = newVal);
  // React的预定义hooks
  var ReactHook = {
      create: (data) => react.useState(data),
      export: stateToData,
      dehydrate: stateToData,
      update: (newVal, states) => forEach(objectKeys(newVal), key => {
          states[key][1](newVal[key]);
      }),
      effectRequest({ handler, removeStates, saveStates, immediate, frontStates, watchingStates = [] }) {
          // 当有监听状态时，状态变化再触发
          const needEmit = react.useRef(immediate);
          const oldStates = watchingStates.map(s => react.useRef(s)); // 用于对比新旧值
          react.useEffect(() => {
              // 对比新旧状态，获取变化的状态索引
              let changedIndex = undefinedValue;
              forEach(watchingStates, (newState, i) => {
                  if (!Object.is(refCurrent(oldStates[i]), newState)) {
                      changedIndex = i;
                      oldStates[i].current = newState;
                  }
              });
              refCurrent(needEmit) ? handler(changedIndex) : setRef(needEmit, trueValue);
              return removeStates; // 组件卸载时移除对应状态
          }, watchingStates);
          // 因为react每次刷新都会重新调用usehook，因此每次会让状态缓存失效
          // 因此每次都需要更新管理的状态
          const needSave = react.useRef(false);
          const saveStatesFn = react.useCallback(saveStates, []);
          react.useEffect(() => {
              refCurrent(needSave) ? saveStatesFn(frontStates) : setRef(needSave, trueValue);
          });
      }
  };

  return ReactHook;

}));
